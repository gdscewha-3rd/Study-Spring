# [기본] 섹션 1 객체 지향 설계와 스프링

## 이야기 - 자바 진영의 추운 겨울과 스프링의 탄생

- 자바 진영에서 표준 기술 EJB (Enterprise Java Beans)
    - 당시 EJB를 앞세워서 영업했다 → 컨테이너, 트랜잭션 관리, 분산 기술 지원이 good
    - BUT EJB 지옥...
        - 어렵고 복잡하고 느리다.. 게다가 너무 비싸다..
        - ‘다시 Java로 돌아가자’라는 의견도 있었다고 한다

- 스프링
    - Rod Johnson
    - EJB 컨테이너 대체
    - 단순함의 승리
    - 현재 사실상 표준 기술

- 하이버네이트
    - EJB 엔티티빈 기술을 대체
    - JPA(Java Persistence API) 새로운 표준 정의

<br>

### 스프링의 역사 ~~*(전설의 시작)*~~

- 2002년 Rod Johnson이 책 출간
- EJB의 문제점을 지적하며 등장
- EJB가 없어도 충분히 고품질의 확장 가능한 애플리케이션을 개발할 수 있다! → 30,000라인 이상의 기술을 예제 코드로 선보임
- 여기에 지금의 스프링 핵심 개념과 기반 코드가 들어있다
- 특징 : BeanFactory, ApplicationContext, POJO(Plain Old Java Object), 제어의 역전, 의존관계 주입
- 책이 유명해지면서 개발자들이 책의 예제 코드를 프로젝트에 사용하기 시작
- 스프링 이름은... 전통적인 J2EE(EJB)라는 겨울을 넘어 새로운 시작이라는 의미로 지었다고 한다!

- 스프링 역사 (릴리즈)
    - 2003년 스프링 프레임워크 1.0 출시 - XML
    - ....
    - 2014년 스프링부트 1.0 출시
    - 2020년 9월 스프링 프레임워크 5.2.x, 스프링부트 2.3.x
    - soon.. 스프링 프레임워크 6, 스프링부트 3

<br>
<br>

## 스프링이란?

### 스프링 생태계

- 필수
    - 스프링 프레임워크
    - 스프링 부트
- 선택
    - 스프링 데이터
    - 스프링 시큐리티
    - 스프링 배치
    - 스프링 세션
    - 스프링 Rest Docs
    - 스프링 클라우드

- [Spring makes Java simple. (스프링 사이트)](http://spring.io)

<br>

### 스프링 프레임워크

- 핵심 기술 : 스프링 DI 컨테이너, AOP, 이벤트, 기타
- 웹 기술 : 스프링 MVC, 스프링 WebFlux
- 데이터 접근 기술 : 트랜잭션, JDBC, ORM 지원, XML 지원
- 기술 통합 : 캐시, 이메일, 원격접근, 스케줄링
- 테스트 : 스프링 기반 테스트 지원
- 언어 : 코틀린, 그루비
- 최근에는 스프링 부트를 통해 스프링 프레임워크의 기술들을 편리하게 사용

<br>

### 스프링 프레임워크 장점

- **스프링을 편리하게 사용할 수 있도록 지원, 최근에는 기본으로 사용**
- 단독으로 실행할 수 있는 스프링 애플리케이션을 쉽게 생성
- Tomcat 같은 웹 서버를 내장해서 별도의 웹 서버를 설치하지 않아도 됨
    - 예전에는 build 후 Tomcat 웹 서버를 별도로 설치, 연결 시키는 등 복잡했었음
- 손쉬운 빌드 구성을 위한 starter 종속성 제공
    - 여러 개의 라이브러리를 구성할 때 starter를 통해 한번에 가져올 수 있도록 함
- 스프링과 3rd parth(외부) 라이브러리 자동 구성
    - 외부 라이브러리 버전에 대해 자동으로 구성해준다
- 메트릭, 상태 확인, 외부 구성과 같은 프로덕션 준비 기능 제공 (모니터링)
- 관례에 의한 간결한 설정
    - 꼭 필요할 때만 custom으로 설정하면 된다

- 스프링부트는 스프링 프레임워크를 기반으로 **편리하게 사용할 수 있도록 도와주는 기술**이지, 단독으로 돌아갈 수 있는 기술은 아니다!!

<br>

### 스프링 단어

- 스프링이라는 단어는 문맥에 따라 다르게 사용된다
    - 스프링 DI 컨테이너 기술
        - 스프링 빈 관리
    - 스프링 프레임워크
    - 스프링 부트, 스프링 프레임워크 등을 모두 포함한 스프링 생태계

<br>

### 스프링은 왜 만들었는가?

- 핵심 개념? (왜 만들었지? 핵심 컨셉은?)
    - 웹 어플리케이션을 만들고, DB 접근 편리하게 하는 기술?
    - 전자정부 프레임워크?
    - 웹 서버도 자동으로 띄워주고?
    - 클라우드, 마이크로서비스?

- 스프링의 진짜 핵심
    - 스프링은 자바 언어 기반의 프레임워크
    - 자바 언어의 가장 큰 특징 - **객체 지향 언어**
    - 스프링은 객체 지향 언어가 가진 강력한 특징을 살려내는 프레임워크
        - EJB를 사용하면 코드가 굉장히 길고 지저분해지면서 EJB 의존성이 커지고 객체 지향 언어가 가지고 있는 장점들을 다 잃어버리게 된다
    - 스프링은 **좋은 객체 지향 어플리케이션을 개발할 수 있게** 도와주는 프레임워크

<br>
<br>

## 좋은 객체 지향 프로그래밍이란?

### 객체 지향의 특징

- 추상화, 캡슐화, 상속, 다형성

<br>

### 객체 지향 프로그래밍

- 객체 지향 프로그래밍은 컴퓨터 프로그램을 명령어의 목록으로 보는 시각에서 벗어나 여러 개의 독립된 단위, 즉 **“객체"들의 모임**으로 파악하고자 하는 것이다. 각각의 객체는 메시지를 주고받고, 데이터를 처리할 수 있다. (협력)
- 객체 지향 프로그래밍은 프로그램을 **유연하고 변경이 용이하게** 만들기 때문에 대규모 소프트웨어 개발에 많이 사용된다.

- [객체 지향 프로그래밍 - 위키백과, 우리 모두의 백과사전](https://ko.wikipedia.org/wiki/%EA%B0%9D%EC%B2%B4_%EC%A7%80%ED%96%A5_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D)

- 유연하고 변경이 용이하게?
    - 레고 블록 조립하듯
    - 키보드, 마우스 갈아끼우듯
    - 컴퓨터 부품 갈아끼우듯
    - 컴포넌트를 쉽고 유연하게 변경하면서 개발할 수 있는 방법
    - `다형성`

<br>

### 다형성 (Polymorphism)

- 다형성의 실세계 비유
    - 실세계와 객체 지향을 1:1로 매칭X (실세계 비유로 이해하긴 좋음!)
    - **역할(인터페이스)과 구현(객체)**으로 세상을 구분
    - ex) 운전자-자동차, 공연무대, 키보드/마우스/세상의 표준 인터페이스들, 정렬 알고리즘, 할인 정책 로직 등

- 운전자 - 자동차 예제
    - 자동차가 바뀌어도 운전자는 역할(=운전)이 바뀌지 않는다!
    - 운전자는 자동차의 역할(인터페이스)에 의존
    - 자동차를 바꿔도 운전자(클라이언트)는 영향을 받지 않는다 → 클라이언트를 바꾸지 않고 새로운 자동차를 얼마든지 확장할 수 있다!
    

- 공연무대 (로미오와 줄리엣 공연)
    - 로미오와 줄리엣은 대본을 읽을 수 있는 사람이면 누구든지 할 수 있다
    - 로미오(클라이언트), 줄리엣(서버)라고 가정 → 줄리엣역 배우가 바뀐다고 해도 로미오역의 특징이 바뀌는가? NO
    
    → 유연하고 변경 용이하다
    
<br>

### 역할과 구현을 분리

- 역할과 구현으로 구분하면 세상이 단순해지고, 유연해지며 변경도 편리
- 장점
    - **클라이언트**는 대상의 역할(인터페이스)만 알면 됨
    - **클라이언트**는 구현 대상의 내부 구조 몰라도 됨
    - **클라이언트**는 구현 대상의 내부 구조가 변경되어도 영향 받지 않음
    - **클라이언트**는 구현 대상 자체를 변경해도 영향 받지 않음
    
- In Java
    - 자바 언어의 다형성을 활용
    - `역할` = 인터페이스
    - `구현` = 인터페이스를 구현한 클래스, 구현 객체
    - 객체를 설계할 때 역할과 구현을 명확하게 분리
    - 객체 설계 시, 역할(인터페이스) 먼저 부여, 그 역할을 수행하는 구현 객체 만들기

<br>

### 객체의 협력

- 혼자 있는 객체는 없다!
- `클라이언트 : 요청`, `서버 : 응답`
- 수많은 객체 클라이언트와 객체 서버는 서로 협력 관계를 가진다

<br>

### 자바 언어에서의 다형성

- 오버라이딩
    - 자바 기본 문법
    - 결과적으로 오버라이딩 된 메서드가 실행
    - 다형성으로 인터페이스를 구현한 객체를 실행 시점에 유연하게 변경할 수 있다는 장점
    - 물론 클래스 상속 관계도 다형성, 오버라이딩 적용 가능

<br>

### 다형성의 본질

- 인터페이스를 구현한 객체 인스턴스를 **실행 시점에 유연하게 변경**할 수 있다
- 다형성의 본질을 이해하기 위해 **협력**이라는 객체 사이의 관계에서 시작해야 함
- **클라이언트를 변경하지 않고, 서버의 구현 기능을 유연하게 변경할 수 있다**

<br>

### 역할과 구현을 분리 (정리)

- 실세계의 역할과 구현이라는 컨셉 → 다형성을 통해 객체 세상에 적용
- 유연하고 변경이 용이
- 확장 가능한 설계
- 클라이언트에 영향을 주지 않는 변경 가능
- 인터페이스를 안정적으로 잘 설계하는 것이 중요

<br>

### 역할과 구현을 분리 (한계)

- 역할(인터페이스) 자체가 변하면 클라이언트, 서버 모두에 큰 변경이 발생
    - 자동차를 비행기로 변경해야 한다면?
    - 대본 자체가 변경된다면?
    - USB 인터페이스가 변경된다면?
- 인터페이스를 안정적으로 잘 설계하는 것이 중요

<br>

### 스프링과 객체 지향

- **다형성**이 가장 중요!!! (객체 지향의 꽃)
- 스프링은 다형성을 극대화해서 이용할 수 있게 도와준다
- 스프링에서 이야기하는 제어의 역전(IoC), 의존관계 주입(DI)은 다형성을 활용해서 역할과 구현을 편리하게 다룰 수 있도록 지원
- 스프링을 사용하면 구현을 편리하게 변경할 수 있다! (like 레고 블록 조립 or 공연 배우 선택 등)

<br>
<br>

## 좋은 객체 지향 설계의 5가지 원칙 (SOLID)

### SOLID

클린코드로 유명한 로버트 마틴이 좋은 객체 지향 설계의 5가지 원칙 정리

~~면접에 종종 나온다고 함..~~

- SRP : 단일 책임 원칙 (Single Responsibility Principle)
- OCP : 개방-폐쇄 원칙 (Open/Closed Principle)
- LSP : 리스코프 치환 원칙 (Liskov Subsitution Principle)
- ISP : 인터페이스 분리 원칙 (Interface Segregation Principle)
- DIP : 의존관계 역전 원칙 (Dependency Inversion Principle)

<br>

### SRP : 단일 책임 원칙 (Single Responsibility Principle)

- 한 클래스는 하나의 책임만 가져야 한다
- 하나의 책임 (모호한 개념)
    - 클 수도 있고, 작을 수도 있다
    - 문맥과 상황에 따라 다르다
- 중요한 기준은 **변경**! 변경이 있을 때 파급 효과가 적으면 단일 책임 원칙을 잘 따른 것
- ex) UI 변경, 객체의 생성과 사용 분리

<br>

### OCP : 개방-폐쇄 원칙 (Open/Closed Principle)

- 소프트웨어 요소는 **확장에는 open, 변경에는 closed!**
- 확장을 하려면 당연히 기존 코드를 변경해야하지 않나?
- **다형성**을 활용해보자!
- 인터페이스를 구현한 새로운 클래스를 하나 만들어서 새로운 기능을 구현
- 지금까지 배운 역할과 구현의 분리를 생각해보자

**문제점**

```java
public class MemberService {
    private MemberRepository memberRepository = new MemoryMemberRepository();
}
```

```java
public class MemberService {
    // private MemberRepository memberRepository = new MemoryMemberRepository();
    private MemberRepository memberRepository = new JdbcMemberRepository();
}
```

- `MemberService` 클라이언트가 구현 클래스를 직접 선택
- **구현 객체를 변경하려면 클라이언트 코드를 변경해야 한다!**
    - 즉, `MemoryMemberRepository` 를 변경하기 위해 `MemberService` 를 변경해야한다!
- 분명 다형성을 사용했지만 OCP 원칙을 지킬 수 없다
- To solve..
    - 객체를 생성하고, 연관관계를 맺어주는 별도의 조립, 설정자가 필요 (나중에 코드로 학습할 것)

<br>

### LSP : 리스코프 치환 원칙 (Liskov Subsitution Principle)

- 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다
- **다형성에서 하위 클래스는 인터페이스 규약을 다 지켜야 한다**는 것, 다형성을 지원하기 위한 원칙, 인터페이스를 구현한 구현체는 믿고 사용하려면 이 원칙이 필요
- 단순히 컴파일이 된다 안된다 라는 개념을 넘어서는 이야기
- ex) 자동차 인터페이스에서 엑셀은 전진 기능으로 설정, 후진 기능 구현하려면 LSP 위반, 느리더라도 앞으로 가야한다

<br>

### ISP : 인터페이스 분리 원칙 (Interface Segregation Principle)

- 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다 **(인터페이스를 잘 쪼개는 것이 좋다!)**
    - 자동차 인터페이스 → 운전 인터페이스, 정비 인터페이스로 분리
    - 사용자 클라이언트 → 운전자 클라이언트, 정비사 클라이언트로 분리
    - 분리하면 정비 인터페이스 자체가 바뀌어도 운전자 클라이언트에 영향 X
- 인터페이스가 명확해지고, 대체 가능성이 높아짐

<br>

### DIP : 의존관계 역전 원칙 (Dependency Inversion Principle)

- 프로그래머는 “추상화에 의존해야지, 구체화에 의존하면 안된다”
- 의존성 주입은 이 원칙을 따르는 방법 중 하나
- **구현 클래스에 의존하지 말고, 인터페이스에 의존하라!**
- **역할(Role)에 의존하게 해야 한다**는 것. 객체 세상도 클라이언트가 인터페이스에 의존해야 유연하게 구현체를 변경할 수 있다. 구현체에 의존하게 되면 변경이 아주 어려워진다.
    - ex) 운전자는 자동차 역할 자체에 대해서만 알면 되는것이지, 테슬라, K3 등에 대해서는 몰라도 된다
- 그런데.. OCP에서 설명한 `MemberService` 는 인터페이스와 구현 클래스 동시에 의존
    - `MemberService` 클라이언트가 구현 클래스를 직접 선택
        - `MemberRepository m = new MemoryMemberRepository();`
    - **DIP 위반** (MemberRepository라는 추상화에도 의존하고, 구체화인 MemoryMemberRepository에도 의존)

<br>

### 정리

- **객체 지향의 핵심은 다형성**!
- 다형성만으로는 쉽게 부품을 갈아 끼우듯 개발할 수 없다
- 다형성만으로는 구현 객체를 변경할 때 클라이언트 코드도 함께 변경된다
- 다형성만으로는 OCP, DIP를 지킬 수 없다 (뭔가 더 필요..)

<br>
<br>

## 객체 지향 설계와 스프링

### 다시 스프링으로...

스프링 이야기하는데 왜 객체 지향 이야기가 나오나요?

- 스프링은 아래의 기술로 **다형성, OCP, DIP**를 가능하게 지원해준다!!
    - DI(Dependency Injection) : 의존관계, 의존성 주입
    - DI 컨테이너 제공
- 클라이언트 코드의 변경 없이 기능 확장
- 쉽게 부품을 교체하듯 개발할 수 있다!

**스프링이 없던 시절**

- 어떤 개발자가 좋은 객체 지향 개발을 하기 위해 OCP, DIP 원칙을 지키면서 개발하려고 시도! 근데 지켜야할 게 너무 많고, 추가되는 것도 많았다.. → 결국 프레임워크로 만들어버림!
- 순수하게 자바로 OCP, DIP 원칙들을 지키면서 개발 하려면 결국 스프링 프레임워크(DI 컨테이너)를 만들게 된다
- DI 개념은 코드로 직접 짜보면 이해하기 쉽고 필요성도 더 잘 느낄 수 있다!

<br>

### 정리

- 모든 설계에 역할과 구현 분리
- 좋은 객체 지향 설계란, 언제든지 유연하게 변경이 용이한 것
- 이상적으로 모든 설계에 인터페이스를 부여하자

- 실무 고민
    - 인터페이스를 도입하면(or 무분별하게 남발하면) 추상화라는 비용이 발생
    - 기능을 확장할 가능성이 없다면, 구체 클래스를 직접 사용하고, 향후 꼭 필요할 때 리팩터링해서 인터페이스를 도입하는 것도 방법!

<br>

## Reference
- [인프런 스프링 핵심 원리 - 기본편](https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8)
- [History of Spring Framework and Spring Boot](https://www.quickprogrammingtips.com/spring-boot/history-of-spring-framework-and-spring-boot.html)
- [객체 지향 프로그래밍 - 위키백과](https://ko.wikipedia.org/wiki/%EA%B0%9D%EC%B2%B4_%EC%A7%80%ED%96%A5_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D)
- [SOLID(객체 지향 설계) - 위키백과](https://ko.wikipedia.org/wiki/SOLID_(%EA%B0%9D%EC%B2%B4_%EC%A7%80%ED%96%A5_%EC%84%A4%EA%B3%84))

